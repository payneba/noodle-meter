<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noodle's Running Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 400px;
            width: 100%;
            text-align: center;
        }

        .hamster-image {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid #fff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            background: #e0e0e0;
        }

        .date {
            font-size: 1.5rem;
            color: #555;
            margin-bottom: 15px;
        }

        .distance-container {
            display: flex;
            align-items: baseline;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .distance {
            font-size: 4rem;
            font-weight: 800;
            color: #2c3e50;
            line-height: 1;
            transition: all 0.3s ease;
        }

        .distance-label {
            font-size: 1.8rem;
            font-weight: 600;
            color: #666;
        }

        /* Tier styles */
        .tier-low .distance {
            font-size: 3.5rem;
            color: #5dade2;
        }
        .tier-low .distance-label {
            color: #5dade2;
        }

        .tier-medium .distance {
            font-size: 4rem;
            color: #58d68d;
        }
        .tier-medium .distance-label {
            color: #58d68d;
        }

        .tier-high .distance {
            font-size: 4.5rem;
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }
        .tier-high .distance-label {
            color: #f39c12;
        }

        .tier-record .distance {
            font-size: 5rem;
            color: #e74c3c;
            text-shadow: 0 0 30px rgba(231, 76, 60, 0.6), 0 0 60px rgba(231, 76, 60, 0.4);
            animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55), pulse 2s ease-in-out infinite;
        }
        .tier-record .distance-label {
            color: #e74c3c;
            text-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        /* Badge styles */
        .badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 15px;
            animation: badgeIn 0.5s ease-out 0.2s both;
        }

        @keyframes badgeIn {
            0% { transform: translateY(-10px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        .badge-low {
            background: linear-gradient(135deg, #ebf5fb, #d4e6f1);
            color: #2980b9;
            border: 2px solid #5dade2;
        }

        .badge-medium {
            background: linear-gradient(135deg, #eafaf1, #d5f5e3);
            color: #27ae60;
            border: 2px solid #58d68d;
        }

        .badge-high {
            background: linear-gradient(135deg, #fef9e7, #fcf3cf);
            color: #d68910;
            border: 2px solid #f39c12;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.3);
        }

        .badge-record {
            background: linear-gradient(135deg, #fdedec, #f5b7b1);
            color: #c0392b;
            border: 2px solid #e74c3c;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.4);
            animation: badgeIn 0.5s ease-out 0.2s both, badgePulse 1.5s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.4); }
            50% { box-shadow: 0 0 30px rgba(231, 76, 60, 0.7); }
        }

        /* Confetti canvas */
        #confetti {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .navigation {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            justify-content: space-between;
            width: 100%;
            left: 0;
            padding: 0 10px;
            pointer-events: none;
        }

        .nav-btn {
            pointer-events: auto;
            background: rgba(255,255,255,0.9);
            border: none;
            font-size: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            color: #333;
        }

        .nav-btn:hover:not(:disabled) {
            background: #fff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            transform: scale(1.05);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .nav-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .loading {
            margin-top: 50px;
            display: flex;
            justify-content: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(
                #f39c12 0deg 45deg,
                #e0e0e0 45deg 90deg,
                #f39c12 90deg 135deg,
                #e0e0e0 135deg 180deg,
                #f39c12 180deg 225deg,
                #e0e0e0 225deg 270deg,
                #f39c12 270deg 315deg,
                #e0e0e0 315deg 360deg
            );
            animation: spin 1s linear infinite;
            box-shadow: inset 0 0 0 8px #fff, inset 0 0 0 10px #ccc, 0 2px 8px rgba(0,0,0,0.15);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error {
            font-size: 1.2rem;
            color: #c0392b;
            margin-top: 50px;
        }

        .revs {
            font-size: 1rem;
            color: #888;
            margin-top: 20px;
        }

        @media (max-width: 480px) {
            .distance {
                font-size: 3rem;
            }
            .nav-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="confetti"></canvas>

    <div class="container">
        <img src="noodle_cropped.jpg" alt="Noodle the hamster" class="hamster-image">

        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
            </div>
        </div>
    </div>

    <nav class="navigation">
        <button class="nav-btn" id="prev-btn" disabled>&larr;</button>
        <button class="nav-btn" id="next-btn" disabled>&rarr;</button>
    </nav>

    <script>
        const DATA_URL = 'https://script.google.com/macros/s/AKfycbxoKRMGYPQAxMCUerc8ZO2MPxJl_aeTZRwIzMYej86asddpN4IzkjgOggQMnLtKUCIzuQ/exec';

        let data = [];
        let currentIndex = 0;
        let thresholds = { p25: 0, p75: 0, max: 0 };

        // Confetti system
        const confettiCanvas = document.getElementById('confetti');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiParticles = [];
        let confettiAnimating = false;

        function resizeConfetti() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        resizeConfetti();
        window.addEventListener('resize', resizeConfetti);

        function createConfetti(count = 100) {
            const colors = ['#e74c3c', '#f39c12', '#f1c40f', '#e67e22', '#ff6b6b', '#feca57'];
            for (let i = 0; i < count; i++) {
                confettiParticles.push({
                    x: Math.random() * confettiCanvas.width,
                    y: -20 - Math.random() * 100,
                    size: Math.random() * 8 + 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    speedY: Math.random() * 3 + 2,
                    speedX: (Math.random() - 0.5) * 4,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    shape: Math.random() > 0.5 ? 'rect' : 'circle'
                });
            }
            if (!confettiAnimating) {
                confettiAnimating = true;
                animateConfetti();
            }
        }

        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

            confettiParticles = confettiParticles.filter(p => p.y < confettiCanvas.height + 20);

            confettiParticles.forEach(p => {
                p.y += p.speedY;
                p.x += p.speedX;
                p.rotation += p.rotationSpeed;

                confettiCtx.save();
                confettiCtx.translate(p.x, p.y);
                confettiCtx.rotate(p.rotation * Math.PI / 180);
                confettiCtx.fillStyle = p.color;

                if (p.shape === 'rect') {
                    confettiCtx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
                } else {
                    confettiCtx.beginPath();
                    confettiCtx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                    confettiCtx.fill();
                }
                confettiCtx.restore();
            });

            if (confettiParticles.length > 0) {
                requestAnimationFrame(animateConfetti);
            } else {
                confettiAnimating = false;
            }
        }

        function calculatePercentile(arr, p) {
            const sorted = [...arr].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            if (lower === upper) return sorted[lower];
            return sorted[lower] + (sorted[upper] - sorted[lower]) * (index - lower);
        }

        function calculateThresholds() {
            const distances = data.map(d => d.distance);
            thresholds.p25 = calculatePercentile(distances, 25);
            thresholds.p75 = calculatePercentile(distances, 75);
            thresholds.max = Math.max(...distances);
        }

        function getTier(distance) {
            if (distance === thresholds.max) return 'record';
            if (distance > thresholds.p75) return 'high';
            if (distance >= thresholds.p25) return 'medium';
            return 'low';
        }

        function getBadge(tier, distance) {
            const badges = {
                record: { text: 'New Record!', class: 'badge-record' },
                high: { text: 'Speed Demon!', class: 'badge-high' },
                medium: { text: 'Steady Runner', class: 'badge-medium' },
                low: { text: 'Rest Day', class: 'badge-low' }
            };
            return badges[tier];
        }

        const CACHE_KEY = 'noodle_meter_cache';

        function getTodayString() {
            return new Date().toLocaleDateString('en-US');
        }

        function hasTodayData(dataArray) {
            const today = getTodayString();
            return dataArray.some(row => row.date === today);
        }

        function loadFromCache() {
            try {
                const cached = localStorage.getItem(CACHE_KEY);
                if (!cached) return null;
                const { data: cachedData, cachedAt } = JSON.parse(cached);
                // Cache is valid if it was cached today and has today's data
                if (cachedAt === getTodayString() && hasTodayData(cachedData)) {
                    return cachedData;
                }
            } catch (e) {
                console.warn('Cache read failed:', e);
            }
            return null;
        }

        function saveToCache(dataArray) {
            // Only cache if we have today's data
            if (!hasTodayData(dataArray)) {
                console.log('Not caching - no data for today yet');
                return;
            }
            try {
                localStorage.setItem(CACHE_KEY, JSON.stringify({
                    data: dataArray,
                    cachedAt: getTodayString()
                }));
            } catch (e) {
                console.warn('Cache write failed:', e);
            }
        }

        function processData(dataArray) {
            data = dataArray;
            calculateThresholds();

            // Find today's date or most recent
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            currentIndex = data.length - 1; // Default to most recent

            for (let i = data.length - 1; i >= 0; i--) {
                const entryDate = new Date(data[i].date);
                entryDate.setHours(0, 0, 0, 0);
                if (entryDate <= today) {
                    currentIndex = i;
                    break;
                }
            }

            updateDisplay();
        }

        async function fetchData() {
            // Try cache first for instant display
            const cachedData = loadFromCache();
            if (cachedData) {
                console.log('Using cached data');
                processData(cachedData);
                return;
            }

            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) throw new Error('Failed to fetch data');

                const jsonData = await response.json();

                // Convert date strings and ensure numeric types
                const processedData = jsonData.map(row => ({
                    date: new Date(row.date).toLocaleDateString('en-US'),
                    revs: Number(row.revs),
                    distance: Number(row.distance)
                }));

                if (processedData.length === 0) {
                    showError('No data found in spreadsheet');
                    return;
                }

                saveToCache(processedData);
                processData(processedData);
            } catch (error) {
                showError('Could not load data. Please check that the spreadsheet is public.');
                console.error(error);
            }
        }

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        function updateDisplay(animate = true) {
            const entry = data[currentIndex];
            const content = document.getElementById('content');
            const tier = getTier(entry.distance);
            const badge = getBadge(tier);

            content.innerHTML = `
                <div class="date">${formatDate(entry.date)}</div>
                <div class="distance-container tier-${tier}" ${animate ? 'style="animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);"' : ''}>
                    <span class="distance">${entry.distance.toFixed(2)}</span>
                    <span class="distance-label">miles</span>
                </div>
                <div class="badge ${badge.class}">${badge.text}</div>
                <div class="revs">${entry.revs.toLocaleString()} wheel revolutions</div>
            `;

            // Trigger confetti for high tier or record
            if (animate && (tier === 'high' || tier === 'record')) {
                createConfetti(tier === 'record' ? 150 : 80);
            }

            // Update navigation buttons
            document.getElementById('prev-btn').disabled = currentIndex === 0;
            document.getElementById('next-btn').disabled = currentIndex === data.length - 1;
        }

        function showError(message) {
            document.getElementById('content').innerHTML = `
                <div class="error">${message}</div>
            `;
        }

        // Navigation handlers
        document.getElementById('prev-btn').addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateDisplay();
            }
        });

        document.getElementById('next-btn').addEventListener('click', () => {
            if (currentIndex < data.length - 1) {
                currentIndex++;
                updateDisplay();
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && currentIndex > 0) {
                currentIndex--;
                updateDisplay();
            } else if (e.key === 'ArrowRight' && currentIndex < data.length - 1) {
                currentIndex++;
                updateDisplay();
            }

            // Ctrl+Shift+R: Clear cache and reload
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                localStorage.removeItem(CACHE_KEY);
                console.log('Cache cleared');
                location.reload();
            }
        });

        // Initialize
        fetchData();
    </script>
</body>
</html>
